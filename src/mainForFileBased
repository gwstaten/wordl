/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */
#include "search.hpp"

std::vector<std::string> validWords;
std::ifstream mainfin("commands");
std::ofstream mainfout("out");

int main()
{
  std::string in;
  std::vector<std::string> valids;
  mainfin >> in;
  std::string hardmode;
  mainfin >> hardmode;

  std::string filePath;
  if(hardmode.at(0) == 'y')
  {
    filePath = "wordl/log/" + in + "-hard";
  }
  else
  {
    filePath = "wordl/log/" + in;
  }

  if(!ghc::filesystem::exists(filePath))
  {
    ghc::filesystem::create_directories(filePath);
  }

  filePath += "/S";
  std::ifstream fin("wordl/wordlists/" + in);
  if(!fin)
  {
    mainfout << "ERROR invalid word list";
    return 0;
  }
  std::string temp;
  fin >> temp;
  while(!fin.eof())
  {
    validWords.push_back(temp);
    fin >> temp;
  }
  valids = validWords;
  std::ifstream fin2("wordl/wordlists/&" + in);
  if(fin2)
  {
    validWords.clear();
    fin >> temp;
    while(!fin.eof())
    {
      validWords.push_back(temp);
      fin >> temp;
    }
  }

  std::string fileLocation = filePath;
  int loops = 0;
  while(!mainfin.eof())
  {
    std::string command;
    mainfin >> command;
    if(command == "filter")
    {
      std::string guess;
      mainfin >> guess;
      std::string temp;
      mainfin >> temp;
      if((temp.length() == valids[0].size() && guess.length() == valids[0].size()))
      {
        fileLocation = fileLocation + guess;
        std::vector<int> rating;
        fileLocation = fileLocation + temp;
        for(unsigned int i = 0; i < guess.length(); i++)
        {
          rating.push_back(temp.at(i) - '0');
        }
        valids = filter(valids,std::make_pair(guess, rating));
      }
    }
    else if(command == "printBest")
    {
      if(valids.size() >= 1)
      {
        std::ifstream fin;
        fin.open(fileLocation);
        if(fin)
        {
          std::string g;
          fin >> g;
          double a;
          fin >> a;
          mainfout << g << "` narrows down to  `" << a << "` possibilities on average";
          fin.close();
        }
        else
        {
          fin.close();
          std::pair<std::string, double> best;
          std::pair<std::string, double> best2;
          std::ofstream fout(fileLocation);
          if(hardmode.at(0) == 'y')
          {
            best = fbThreads(valids, valids, 4);
            best2 = best;
          }
          else
          {
            best = fbThreads(valids, valids, 4);
            best2 = fbThreads(valids, validWords, 4);
          }
          if(best2.second >= best.second || hardmode.at(0) == 'y')
          {
            mainfout << best.first << "` narrows down to  `" << best.second << "` possibilities on average";
            fout << best.first << " " << best.second;
          }
          else
          {
            mainfout << best2.first << "` narrows down to  `" << best2.second << "` possibilities on average";
            fout << best2.first << " " << best2.second;
          }
        }
      }
      else
      {
        mainfout << "cannot run find best with the remaining number of words (either there are no words remaining or there are too many remaining)`";
      }
    }
    else if(command == "printRemaining")
    {
      mainfout << valids.size() << " ";
    }
    else if(command == "printPossibilities")
    {
      for(unsigned int i = 0; i < valids.size(); i++)
      {
        mainfout << valids[i] << " ";
      }
    }
  }
}
